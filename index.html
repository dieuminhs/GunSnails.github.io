<!DOCTYPE html>
<html>
<link rel="icon" href="data:;base64,=">

<body>
    <audio id="buttonOverAudio">
    <source src = "sound/buttonOver.mp3" type = "audio/mpeg">
    </audio>
    <script src="bump.js"></script>
    <script src="pixi.min.js"></script>
    <script src="pixi-filters.js"></script>


    <style>
        * {
            padding: 0;
            margin: 0
        }
    </style>
    <script type="text/javascript">
        const menuStyle = new PIXI.TextStyle({
            dropShadow: true,
            dropShadowAlpha: 0.3,
            dropShadowBlur: 6,
            fill: "#761e1e",
            fontFamily: "\"Lucida Console\", Monaco, monospace",
            fontSize: 80,
            fontStyle: "italic",
            fontVariant: "small-caps",
            fontWeight: "bold",
            stroke: "#0dff00",
            strokeThickness: 1
        });
        const healthStyle = new PIXI.TextStyle({
            dropShadowAlpha: 0.3,
            dropShadowBlur: 6,
            fill: "red",
            fontFamily: "Comic Sans MS",
            fontSize: 10,
            fontVariant: "small-caps",
            fontWeight: "bold",
            stroke: "white",
            strokeThickness: 1
        });
        const turnStyle = new PIXI.TextStyle({
            dropShadow: true,
            dropShadowAlpha: 0.3,
            dropShadowBlur: 2,
            dropShadowDistance: 8,
            fill: "red",
            fontFamily: "\"Comic Sans MS\", cursive, sans-serif",
            fontSize: 20,
            fontVariant: "small-caps",
            fontWeight: "bold",
            stroke: "white",
            strokeThickness: 1
        });
        const victoryStyle = new PIXI.TextStyle({
            dropShadow: true,
            dropShadowAlpha: 0.6,
            dropShadowAngle: 0.7,
            dropShadowBlur: 1,
            dropShadowDistance: 6,
            fill: [
                "red",
                "#ffa8a8",
                "#d25151"
            ],
            fontFamily: "Georgia",
            fontSize: 100,
            fontWeight: 600,
            stroke: "white",
            strokeThickness: 1
        });
        const numbStyle = new PIXI.TextStyle({
            fill: [
                "black",
                "#e60000"
            ],
            fontFamily: "Georgia",
            fontSize: 80,
            fontWeight: 600,
            stroke: "white",
            strokeThickness: 1
        });

        const numbText = new PIXI.Text('', numbStyle);

        class Bullet {
            constructor() {
                this.damageZone = 0;

                this.pureDamage = 0;
                //...
                this.pow = 0;
                this.angle = 0;
                this.wind = 0;
                this.g = 0;

            }
        }

        class Snail {
            constructor() {
                this.direction = 0;
                this.health = 4;
            }
        }

        var app = new PIXI.Application();
        var buttonOverAudio = document.getElementById("buttonOverAudio");

        const loader = PIXI.Loader.shared;

        var state;

        var renderTexture;

        var renderTextureSprite;

        var snailAnim;

        const brush = new PIXI.Graphics();
        brush.beginFill(0xFFFFFF);
        brush.drawCircle(0, 0, 50);
        brush.endFill();


        // Ticker render bullet per frame
        const bulletTicker = new PIXI.ticker.Ticker();
        bulletTicker.stop();

        const dropTicker = new PIXI.ticker.Ticker();
        dropTicker.stop();

        const fallTicker = new PIXI.ticker.Ticker();
        fallTicker.stop();

        const chargeTicker = new PIXI.ticker.Ticker();
        chargeTicker.stop();

        const coinTicker = new PIXI.ticker.Ticker();
        coinTicker.stop();

        const turnTicker = new PIXI.ticker.Ticker();
        turnTicker.stop();

        var graphics = new PIXI.Graphics();
        var rectangle = new PIXI.Graphics();
        // t - TimePassed
        let t,
            count;
        // v0 - Power, g - Gravity, a - WindPower
        var v0, angle, g, a,
            moveSpeed = 2.5;
        dropSpeed = 3.5,
            numb = 4,
            left = 4,
            _vx = 0,
            _vy = 0;

        // Powerbar width
        var barWidth = 0.1,
            dir = 1;

        // Create player array
        var player,
            players = [],
            playerdir = 1;

        // Platform outline point array
        var black = [];

        var point = [];

        var nonTransPoint = [];

        var cannon;

        var coins = [];

        // Create button array
        var buttons = [];

        // Sprite for the game
        var spriteBullet;
        let sheet, sheet2, sheet3;

        // Brightness adjustion matrix for filter
        var brightness = 0.2;
        var b = (brightness || 0) + 1;
        var _filter = [
            b, 0, 0, 0, 0,
            0, b, 0, 0, 0,
            0, 0, b, 0, 0,
            0, 0, 0, 1, 0
        ];

        var disable = false;

        var buttonFilter = new PIXI.filters.ColorMatrixFilter();
        buttonFilter.matrix = _filter;

        // Outline filter for sprite
        const outlineFilterBlack = new PIXI.filters.OutlineFilter(1, 0x000000);
        const outlineFilterP = new PIXI.filters.OutlineFilter(1, 0x00FF00);

        //Add the canvas that Pixi automatically created for you to the HTML document
        document.body.appendChild(app.view);

        // Resize the renderer to fit the window screen

        app.renderer.resize(1376, 768);




        // Load image Textures from spritesheet with .json files
        var textureSnail = [];
        var textureButton;
        var textureBullet = PIXI.Texture.fromImage('image/Bullet.png');
        var textureArrowUp;
        var progressBar;
        var textureCannon;

        // playBackground author : <a href='https://www.freepik.com/free-photos-vectors/background'>Background vector created by pikisuperstar - www.freepik.com</a>

        loader.add("image/spriteSheet.json")
            .add("image/explosionSheet.json")
            .add("image/snailAnim.json")
            .add("image/snailAnim2.json")
            .add("image/snailAnim3.json")
            .add("image/snailAnim4.json")
            .add('menuBackground', "image/menuBackground.jpg")
            .add('selectionBackground', "image/selectionBackground.jpg")
            .add('playBackground', "image/playBackground.jpg")
            .add('platform', "image/gunSnail.png")
            .add('progressBar', "image/ProgressBar.png")
            .add('cannon', "image/Cannon.png")
            .add('arrowup', "image/ArrowUp.png")
            .on('progress', loadProgressHandler);

        function loadProgressHandler() {
            //Display the file 'url' being loaded
            console.log('loading: ${resource.url}');

            //Display the currentage of files being loaded
            console.log('progress: ${loader.progress}');
        }


        // Run after the textures have been loaded
        loader.load((loader, resources) => {
            sheet2 = resources["image/spriteSheet.json"].spritesheet;
            sheet = resources["image/explosionSheet.json"].spritesheet;
            snailSheet = [
                resources["image/snailAnim.json"].spritesheet,
                resources["image/snailAnim2.json"].spritesheet,
                resources["image/snailAnim3.json"].spritesheet,
                resources["image/snailAnim4.json"].spritesheet
            ];
            textureButton = [
                sheet2.textures["Play.png"],
                sheet2.textures["Options.png"],
                sheet2.textures["Exit.png"]
            ];
            textureSnail = [
                snailSheet[0].textures["snailAnim-0.png"],
                snailSheet[1].textures["snailAnim2-0.png"],
                snailSheet[2].textures["snailAnim3-0.png"],
                snailSheet[3].textures["snailAnim4-0.png"]
            ];

            textureArrow = resources.arrowup.texture;
            textureCannon = resources.cannon.texture;
            console.log("Texture Loaded!");

            //Create the Container for the Scenes
            menuScene = new PIXI.Container();
            selectionScene = new PIXI.Container();
            playScene = new PIXI.Container();

            app.stage.addChild(menuScene);
            app.stage.addChild(playScene);
            app.stage.addChild(selectionScene);

            playScene.visible = false;
            playScene.alpha = 0;

            selectionScene.visible = false;
            selectionScene.alpha = 0;

            document.body.appendChild(app.view);



            // Create a Background for Scenes

            const background1 = new PIXI.Sprite(resources.menuBackground.texture);
            const background2 = new PIXI.Sprite(resources.selectionBackground.texture);
            const background3 = new PIXI.Sprite(resources.playBackground.texture);
            const background = new PIXI.Sprite(resources.playBackground.texture);


            background.width = app.renderer.width;
            background.height = app.renderer.height;


            background1.width = app.renderer.width;
            background1.height = app.renderer.height;

            background2.width = app.renderer.width;
            background2.height = app.renderer.height;

            background3.width = app.renderer.width;
            background3.height = app.renderer.height;

            renderTexture = PIXI.RenderTexture.create(app.screen.width, app.screen.height);
            renderTextureSprite = new PIXI.Sprite(renderTexture);

            platform = new PIXI.Sprite(resources.platform.texture);
            platform.filters = [outlineFilterP];

            progressBar = new PIXI.Sprite(resources.progressBar.texture);
            progressBar.scale.set(0.5, 0.5);
            progressBar.x = 50;
            progressBar.y = 50;

            graphics.beginFill(0xFF3300);
            graphics.drawRect(progressBar.x, progressBar.y, 0, progressBar.height);
            graphics.endFill();

            //Draw the progress bar border and container
            rectangle.beginFill(0xffffff);
            // set the line style to have a width of 5 and set the color to red
            rectangle.lineStyle(5, 0xFF0000);
            // draw a rectangle
            rectangle.drawRect(progressBar.x + 5, progressBar.y + 3, progressBar.width - 9, progressBar.height - 8);
            rectangle.endFill();

            progressBar.mask = graphics;

            pixels = app.renderer.extract.pixels(platform);

            // add background to Scenes
            menuScene.addChild(background1);

            selectionScene.addChild(background2);

            playScene.addChild(background);
            playScene.addChild(platform);

            // Acquire black points array from the pixels array
            for (i = 0; i < pixels.length / 4; i++) {
                if (pixels[4 * i] == 0 && pixels[4 * i + 1] == 255 && pixels[4 * i + 2] == 0 && pixels[4 * i + 3] > 0) {
                    black[i] = 1;
                } else black[i] = 0;
            }

            for (i = 0; i < platform.height; i++) {
                for (j = 0; j < platform.width; j++) {
                    var temp = new PIXI.Point;
                    var index = j + i * platform.width;
                    if (black[index] == 1) {
                        temp.x = j;
                        temp.y = i;
                        point.push(temp);
                    }
                }
            }

            playScene.addChild(rectangle);
            playScene.addChild(progressBar);



            menuButtons();
            menuText();

            playScene.addChild(background3);

            background3.mask = renderTextureSprite;

            state = menu;
            app.ticker.add(delta => gameLoop(delta));

        });



        function gameLoop(delta) {
            //Update the game current state
            state(delta);
        }

        function switchPlay(delta) {
            //Switch the scene from menu to play
            if (menuScene.alpha > 0) {
                menuScene.alpha -= 0.01;
            } else if (playScene.alpha < 1) {
                menuScene.visible = false;
                playScene.visible = true;
                playScene.alpha += 0.1;
            } else {
                dropTicker.start();

            }
        }

        function switchMenu(delta) {
            //Switch the scene from play to menu
            if (playScene.alpha > 0) {
                playScene.alpha -= 0.1;
            } else if (menuScene.alpha < 1) {
                menuScene.visible = true;
                playScene.visible = false;
                menuScene.alpha += 0.1;
            }
        }

        function switchSelection(delta) {
            //Switch the scene from menu to selection
            if (menuScene.alpha > 0) {
                menuScene.alpha -= 0.1;
            } else if (selectionScene.alpha < 1) {
                selectionScene.visible = true;
                menuScene.visible = false;
                selectionScene.alpha += 0.1;
            } else state = selection;

        }

        function switchOut(delta) {
            //Switch the scene from selection to menu
            if (selection.alpha > 0) {
                selectionScene.alpha -= 0.1;
            } else if (menuScene.alpha < 1) {
                menuScene.visible = true;
                selectionScene.visible = false;
                menuScene.alpha += 0.1;
            } else state = menu;

        }

        function play(delta) {
            player.cannon.angle += _vy;
            if (player.cannon.angle < -360) {
                player.cannon.angle += 360;
            }
            if (player.cannon.angle > 360) {
                player.cannon.angle -= 360;
            }


            player.sprite.x += _vx;
            player.cannon.x += _vx;
            player.hText.x += _vx;
            player.anim.x += _vx;

            if (player.direction != playerdir) {
                player.direction *= -1;
                player.sprite.scale.x *= -1;
                player.anim.scale.x *= -1;
            }
            var b = new Bump();
            var hit = false;

            point.some(function(Point, index) {

                if (b.hitTestPoint({
                            x: Point.x,
                            y: Point.y
                        },
                        player.sprite,
                        true
                    )) {
                    hit = true;
                    return hit;
                }
            });
            if (!hit && player.health > 0) {
                fallTicker.start();
            }

        }

        function victory(delta) {

        }

        function idle(delta) {

        }

        function menu(delta) {
            // Add buttons to the menuScene


        }

        function selection(delta) {
            numbText.text = numb;
        }

        // Do something when a button is clicked
        var buttonClicked = function() {
            switch (this.name) {
                case "Play":
                    {

                        // var cannon = new PIXI.Sprite;

                        for (i = 0; i < numb; i++) {

                            snail = new Snail();
                            snail.sprite = new PIXI.Sprite(textureSnail[i]);
                            snail.sprite.x = Math.random() * (app.renderer.width - 200);

                            snail.sprite.scale.x = 0.15;
                            snail.sprite.scale.y = 0.15;
                            snail.sprite.anchor.set(0.5);


                            snail.sprite.hitArea = new PIXI.Circle(0, 0, 10);
                            snail.sprite.filters = [outlineFilterBlack];


                            players[i] = snail;
                            players[i].direction = Math.floor(Math.random() * 2);


                            cannon = new PIXI.Sprite(textureCannon);
                            cannon.x = snail.sprite.x;
                            cannon.y = snail.sprite.y;
                            cannon.anchor.set(0, 0.5);
                            cannon.scale.x = 0.05;
                            cannon.scale.y = 0.05;
                            cannon.filters = [outlineFilterBlack];
                            players[i].cannon = cannon;


                            snailAnim = new PIXI.AnimatedSprite(snailSheet[i].animations["moving"]);
                            snailAnim.anchor.set(0.5);
                            snailAnim.animationSpeed = 0.25;
                            snailAnim.scale.x = 0.15;
                            snailAnim.scale.y = 0.15;
                            snailAnim.x = app.renderer.width / 2;
                            snailAnim.y = app.renderer.height / 2;
                            snailAnim.filters = [outlineFilterBlack];
                            snailAnim.visible = false;
                            players[i].anim = snailAnim;

                            healthText = new PIXI.Text('', healthStyle);
                            healthText.anchor.set(0.5);
                            healthText.x = snail.sprite.x;
                            healthText.y = snail.sprite.y - snail.sprite.height;
                            healthText.visible = true;

                            players[i].hText = healthText;
                            players[i].hText.text = players[i].health;


                            if (!players[i].direction) {
                                playerdir = -1;
                                players[i].direction = -1;
                                players[i].sprite.scale.x *= -1;
                                players[i].anim.scale.x *= -1;
                            }

                            playScene.addChild(players[i].anim);
                            playScene.addChild(players[i].sprite);
                            playScene.addChild(players[i].cannon);
                            playScene.addChild(players[i].hText);


                        }
                        for (i = 0; i < numb; i++) {
                            if (i + 1 < numb) {
                                players[i].next = players[i + 1];
                            } else {
                                players[i].next = 0;
                            }
                        }

                        player = players[0];

                        dropTicker.add(deltaTime => drop(deltaTime));

                        turnTicker.add(deltaTime => countdown(deltaTime));

                        chargeTicker.add(deltaTime => charge(deltaTime));

                        fallTicker.add(deltaTime => fall(deltaTime));

                        state = switchPlay;

                        break;
                    }
                case "Options":
                    {
                        //Draw a container for number of players
                        rectangle = new PIXI.Graphics();
                        rectangle.beginFill(0xffffff);
                        // set the line style to have a width of 5 and set the color to red
                        rectangle.lineStyle(5, 0xFF0000);
                        // draw a rectangle
                        rectangle.drawRect(app.renderer.width / 2 - 150, app.renderer.height / 2 - 50, 300, 100);
                        rectangle.endFill();

                        //Arrows for selecting number of players
                        arrowUp = new PIXI.Sprite(textureArrow);
                        arrowUp.anchor.set(0.5);
                        arrowUp.x = app.renderer.width / 2 + 200;
                        arrowUp.y = app.renderer.height / 2 - 30;
                        arrowUp.scale.x = 0.3;
                        arrowUp.scale.y = 0.3;


                        arrowDown = new PIXI.Sprite(textureArrow);
                        arrowDown.anchor.set(0.5);
                        arrowDown.x = app.renderer.width / 2 + 200;
                        arrowDown.y = app.renderer.height / 2 + 30;
                        arrowDown.scale.x = 0.3;
                        arrowDown.scale.y = 0.3;
                        arrowDown.angle = 180;

                        arrowUp.interactive = true;
                        arrowDown.interactive = true;

                        arrowUp
                        // set the mousedown and touchstart callback...
                        .on('mousedown', onButtonDown)
                        .on('touchstart', onButtonDown)

                        // set the mouseup and touchend callback...
                        .on('mouseup', onButtonUp)
                        .on('touchend', onButtonUp)
                        .on('mouseupoutside', onButtonUp)
                        .on('touchendoutside', onButtonUp)

                        // set the mouseover callback...
                        .on('mouseover', onButtonOver)

                        // set the mouseout callback...
                        .on('mouseout', onButtonOut)

                        arrowUp.tap = upNumber;
                        arrowUp.click = upNumber;

                        arrowDown
                        // set the mousedown and touchstart callback...
                        .on('mousedown', onButtonDown)
                        .on('touchstart', onButtonDown)

                        // set the mouseup and touchend callback...
                        .on('mouseup', onButtonUp)
                        .on('touchend', onButtonUp)
                        .on('mouseupoutside', onButtonUp)
                        .on('touchendoutside', onButtonUp)

                        // set the mouseover callback...
                        .on('mouseover', onButtonOver)

                        // set the mouseout callback...
                        .on('mouseout', onButtonOut)

                        arrowDown.tap = downNumber;
                        arrowDown.click = downNumber;

                        var exit = new PIXI.Sprite(textureButton[2]);

                        exit.buttonMode = true;
                        exit.anchor.set(0.5);
                        exit.x = 150;
                        exit.y = app.renderer.height - 75;

                        exit.interactive = true;

                        exit // set the mousedown and touchstart callback...
                        .on('mousedown', onButtonDown)
                        .on('touchstart', onButtonDown)

                        // set the mouseup and touchend callback...
                        .on('mouseup', onButtonUp)
                        .on('touchend', onButtonUp)
                        .on('mouseupoutside', onButtonUp)
                        .on('touchendoutside', onButtonUp)

                        // set the mouseover callback...
                        .on('mouseover', onButtonOver)

                        // set the mouseout callback...
                        .on('mouseout', onButtonOut)

                        exit.tap = Exit;
                        exit.click = Exit;

                        numbText.x = app.renderer.width / 2 + 90;
                        numbText.y = app.renderer.height / 2 - 50;



                        selectionScene.addChild(rectangle);

                        selectionScene.addChild(arrowDown);
                        selectionScene.addChild(arrowUp);
                        selectionScene.addChild(numbText);

                        selectionScene.addChild(exit);

                        state = switchSelection;

                        break;
                    }
                case "Exit":
                    {
                        // buttons.forEach(function(button, index) {
                        //   button.interactive = false;
                        //});


                    }
            }
        }

        var shootBullet = function(x, y, type, pow, angle) {

            if (!bulletTicker.started) {
                bullet = new Bullet();
                spriteBullet = new PIXI.Sprite(textureBullet);


                spriteBullet.circular = true;
                // bullet.damageZone = damageZone[type];
                // bullet.pureDamage = pureDamage[type];
                spriteBullet.anchor.set(0.5);
                spriteBullet.x = x;
                spriteBullet.y = y;
                spriteBullet.scale.x = 0.1;
                spriteBullet.scale.y = 0.1;
                playScene.addChild(spriteBullet);
                t = 0;
                bullet.pow = pow,
                    bullet.angle = Math.PI / 180 * angle,
                    bullet.g = 10;
                bullet.wind = 0;

                bulletTicker.start();
            }




        };


        function charge(deltaTime) {

            if (barWidth >= progressBar.width || barWidth <= 0) {
                dir *= -1;
            }
            barWidth += 0.75 * dir;

            graphics = new PIXI.Graphics();
            graphics.beginFill(0x00000);
            graphics.drawRect(progressBar.x, progressBar.y, barWidth, progressBar.height);
            graphics.endFill();

            progressBar.mask = graphics;
        }

        // Adjust bullet position per frame
        function flyout(deltaTime, spriteBullet, bullet) {

            vx = bullet.pow * Math.cos(bullet.angle) + bullet.wind * t / 10;
            vy = bullet.pow * Math.sin(bullet.angle) - bullet.g * t / 10;

            var b = new Bump();
            var hit = false,
                playerHit = false;

            t += 0.2;

            if (spriteBullet.x > app.renderer.width || spriteBullet.y > app.renderer.height) {
                setTimeout(() => {
                    app.ticker.stop();
                    setTimeout(() => {

                        changeTurn();
                    }, 2000);
                }, 500);
                playScene.removeChild(spriteBullet);
                spriteBullet.destroy();
                bulletTicker.stop();
                hit = true;

            } else {
                point.some(function(Point, index) {
                    if (b.hitTestPoint({
                                x: Point.x,
                                y: Point.y
                            },
                            spriteBullet,
                            true
                        )) {

                        explosion = new PIXI.AnimatedSprite(sheet.animations["explosion"]);
                        explosion.anchor.set(0.5);
                        explosion.visible = true;
                        explosion.x = spriteBullet.x;
                        explosion.y = spriteBullet.y;
                        explosion.loop = false;
                        explosion.animationSpeed = 0.5;
                        explosion.circular = true;

                        for (i = 0; i < numb; i++) {
                            if (b.hit(players[i].sprite, explosion)) {
                                players[i].health--;

                                players[i].hText.text = players[i].health;

                                if (players[i].health < 1) {
                                    players[i].sprite.visible = false;
                                    playScene.removeChild(players[i].sprite);
                                    playScene.removeChild(players[i].cannon);
                                    playScene.removeChild(players[i].anim);
                                    playScene.removeChild(players[i].hText);
                                    left--;
                                }

                                playerHit = true;

                            }
                        }

                        playScene.addChild(explosion);
                        explosion.play();




                        explosion.onComplete = function() {
                            setTimeout(() => {
                                app.ticker.stop();
                                setTimeout(() => {

                                    changeTurn();
                                }, 2000);
                            }, 500);

                            playScene.removeChild(explosion);
                            explosion.destroy();
                        }
                        playScene.removeChild(spriteBullet);
                        spriteBullet.destroy();
                        bulletTicker.stop();
                        hit = true;
                        return hit;
                    }

                });
            }

            if (!hit) {
                spriteBullet.x += vx;
                spriteBullet.y -= vy;
            }

        }

        function destroy(x, y) {
            brush.position.set(x, y);

            app.renderer.render(brush, renderTexture, false, null, false);

        }

        function drop(deltaTime) {

            var b = new Bump();
            var stop = true,
                hit = false;

            point.some(function(Point, index) {

                if (b.hitTestPoint({
                            x: Point.x,
                            y: Point.y
                        },
                        player.sprite,
                        true
                    )) {
                    hit = true;
                    return hit;
                }
            });
            if (player.sprite.y > app.renderer.height) {
                console.log("Dead by falling");
                player.health = 0;
                left--;
                playScene.removeChild(player.sprite);
                playScene.removeChild(player.anim);
                playScene.removeChild(player.cannon);
                playScene.removeChild(player.hText);
                hit = true;
            }
            if (!hit) {
                player.sprite.y += dropSpeed;
                player.cannon.y += dropSpeed;
                player.hText.y += dropSpeed;

            } else {
                player.anim.x = player.sprite.x;
                player.anim.y = player.sprite.y;
                if (player.next == 0) {
                    init();
                    dropTicker.stop();
                    if (numb < 2) {
                        console.log("WIN");

                        const victoryText = new PIXI.Text('PLAYER ' + i + ' VICTORY !!!', victoryStyle);


                        victoryText.x = app.renderer.width / 2;
                        victoryText.y = app.renderer.height / 2;
                        victoryText.anchor.set(0.5);
                        playScene.addChild(victoryText);

                        state = victory;
                    } else
                        state = play;
                } else player = player.next;
            }


            count = 0;
            turnTicker.start();
        }

        function fall(deltaTime) {

            disable = true;
            state = idle;
            var b = new Bump();
            var hit = false,
                dead = false;


            point.some(function(Point, index) {

                if (b.hitTestPoint({
                            x: Point.x,
                            y: Point.y
                        },
                        player.sprite,
                        true
                    )) {
                    hit = true;
                    return hit;
                }
            });
            if (player.sprite.y > app.renderer.height) {
                console.log("Dead by falling");
                player.health = 0;
                left--;
                playScene.removeChild(player.sprite);
                playScene.removeChild(player.anim);
                playScene.removeChild(player.cannon);
                playScene.removeChild(player.hText);
                hit = true;
                dead = true;
            }
            if (dead) {
                disable = false;
                changeTurn();
                fallTicker.stop();
                state = play;
            }
            if (!hit) {
                player.sprite.y += dropSpeed;
                player.cannon.y += dropSpeed;
                player.hText.y += dropSpeed;

            } else {

                disable = false;
                player.anim.x = player.sprite.x;
                player.anim.y = player.sprite.y;
                fallTicker.stop();
                state = play;

            }

        }


        function init() {

            var lastKeyUpAt;
            //Capture the keyboard arrow keys
            let left = keyboard(37),
                up = keyboard(38),
                right = keyboard(39),
                down = keyboard(40),
                space = keyboard(32),
                esc = keyboard(27);

            //Left arrow key `press` method
            left.press = () => {
                if (disable) {
                    return;
                }
                //Change the cat's velocity when the key is pressed
                if (!right.isDown) {
                    player.sprite.visible = false;
                    player.anim.visible = true;
                }
                player.anim.play();
                playerdir = -1;
                _vx = -moveSpeed;
                _vy = 0;
            };

            //Left arrow key `release` method
            left.release = () => {
                //If the left arrow has been released, and the right arrow isn't down,
                //and the cat isn't moving vertically:
                //Stop the cat
                player.sprite.visible = true;
                player.anim.visible = false;
                player.anim.stop();
                if (!right.isDown && _vy === 0) {
                    _vx = 0;
                }
            };

            //Up
            up.press = () => {
                _vy = -5;
            };
            up.release = () => {
                if (!down.isDown) {
                    _vy = 0;
                }
            };

            //Right
            right.press = () => {
                if (disable) {
                    return;
                }
                if (!left.isDown) {
                    player.sprite.visible = false;
                    player.anim.visible = true;
                }
                player.anim.play();
                playerdir = 1;
                _vx = moveSpeed;
                _vy = 0;
            };
            right.release = () => {
                player.sprite.visible = true;
                player.anim.visible = false;
                player.anim.stop();
                if (!left.isDown && _vy === 0) {
                    _vx = 0;
                }
            };

            //Down
            down.press = () => {
                _vy = 5;
            };
            down.release = () => {
                if (!up.isDown) {
                    _vy = 0;
                }
            };

            //Space
            space.press = () => {
                state = idle;
                chargeTicker.start();
                var angle2 = player.cannon.angle;
                // shootBullet((cannon.width) * Math.cos(Math.PI * angle2 / 180) + cannon.x, ((cannon.width) * Math.sin(Math.PI * angle2 / 180) + cannon.y), 0, 30, -angle2);
            };

            space.release = () => {
                chargeTicker.stop();
                var angle2 = player.cannon.angle;
                shootBullet((player.cannon.width) * Math.cos(Math.PI * angle2 / 180) + player.cannon.x, ((player.cannon.width) * Math.sin(Math.PI * angle2 / 180) + player.cannon.y), 0, barWidth / 10, -angle2);
            };

            esc.press = () => {

            }

            esc.release = () => {
                state = switchMenu;
            }

            bulletTicker.add(deltaTime => flyout(deltaTime, spriteBullet, bullet));

        }

        function changeTurn() {
            let victoryText;
            if (left < 2) {
                console.log("WIN");
                for (i = 0; i < numb; i++) {
                    if (players[i].health > 0) {
                        i++;
                        victoryText = new PIXI.Text('PLAYER ' + i + ' VICTORY !!!', victoryStyle);
                    }
                }

                victoryText.x = app.renderer.width / 2;
                victoryText.y = app.renderer.height / 2;
                victoryText.anchor.set(0.5);
                playScene.addChild(victoryText);

                state = victory;
                return;
            }
            const turnText = new PIXI.Text('Change Turn!', turnStyle);
            setTimeout(() => {
                turnText.visible = false;
            }, 2000);

            turnText.x = 50;
            turnText.y = 20;
            turnText.visible.true;
            playScene.addChild(turnText);
            state = play;
            player.sprite.visible = true;
            snailAnim.visible = false;
            app.ticker.start();
            if (player.next != 0 && player.next.health > 0) {
                console.log("Changed next!");
                player = player.next;

            } else {
                console.log("Changed another!");
                for (i = 0; i < numb; i++) {
                    if (players[i].health > 0) {
                        player = players[i];
                        break;
                    }
                }

            }
            barWidth = 0.1;
            graphics = new PIXI.Graphics();
            graphics.beginFill(0x00000);
            graphics.drawRect(progressBar.x, progressBar.y, barWidth, progressBar.height);
            graphics.endFill();

            progressBar.mask = graphics;
        }

        function countdown(deltaTime) {

            count += 1 / 60;
        }

        function coinDrop(deltaTime) {
            var b = new Bump();
            var hit = false;
            for (i = 0; i < numb; i++) {
                var coin = new PIXI.AnimatedSprite(sheet3.animations["coin"]);
                coin.anchor.set(0.5);
                coin.x = Math.random() * (app.render.width - 200);
                coin.y = 0;
                coin.loop = true;
                coin.animationSpeed = 0.5;
                coin.play();
                coins[i] = coin;
                playScene.addChild(coins[i]);
            }

            for (i = 0; i < numb; i++) {
                point.some(function(Point, index) {
                    if (b.hitTestPoint({
                                x: Point.x,
                                y: Point.y
                            },
                            coins[i],
                            true)) {
                        hit = true;
                        return hit;
                    }
                });

                if (!hit) {


                }
            }


        }

        function menuText() {

            const text = new PIXI.Text('Welcome to Gunsnail', menuStyle);
            text.anchor.set(0.5);
            text.x = app.renderer.width / 2;
            text.y = 0.7 * app.renderer.height / 5;
            menuScene.addChild(text);
        }

        function menuButtons() {
            // Create name array to specify buttons
            var name = [
                "Play",
                "Options",
                "Exit"
            ]

            // Create position array for buttons
            var buttonPositions = [
                app.renderer.width / 2, 1.5 * app.renderer.height / 5,
                app.renderer.width / 2, 2.5 * app.renderer.height / 5,
                app.renderer.width / 2, 3.5 * app.renderer.height / 5
            ];
            for (var i = 0; i < 3; i++) {
                var button = new PIXI.Sprite(textureButton[i]);
                button.buttonMode = true;

                button.anchor.set(0.5);
                button.name = name[i];
                button.position.x = buttonPositions[i * 2];
                button.position.y = buttonPositions[i * 2 + 1];

                // make the button interactive...
                button.interactive = true;


                button
                // set the mousedown and touchstart callback...
                    .on('mousedown', onButtonDown)
                    .on('touchstart', onButtonDown)

                // set the mouseup and touchend callback...
                .on('mouseup', onButtonUp)
                    .on('touchend', onButtonUp)
                    .on('mouseupoutside', onButtonUp)
                    .on('touchendoutside', onButtonUp)

                // set the mouseover callback...
                .on('mouseover', onButtonOver)

                // set the mouseout callback...
                .on('mouseout', onButtonOut)


                // you can also listen to click and tap events :
                //.on('click', shootBullet)

                button.tap = buttonClicked;
                button.click = buttonClicked;
                // add it to the app.stage
                menuScene.addChild(button);

                // add button to array
                buttons.push(button);



            }
        }

        function onButtonDown() {
            this.isDown = true;
            this.filters = null;

        }

        function onButtonUp() {
            this.isDown = false;
            if (this.isOver) {
                this.filters = [buttonFilter];
            } else {

            }

        }

        function onButtonOver() {
            this.isOver = true;
            if (this.isDown) {
                return;
            }
            // Adjust buttonOver texture
            this.filters = [buttonFilter];

            buttonOverAudio.play();
        }

        function onButtonOut() {
            this.isOver = false;
            if (this.isDown) {
                return;
            }
            // Adjust buttonOut texture
            this.filters = null;

        }

        function upNumber() {
            if (numb < 4) {
                numb++;
                left++;
            }
        }

        function downNumber() {
            if (numb > 1) {
                numb--;
                left--;
            }
        }

        function Exit() {
            state = switchOut;
        }

        function keyboard(keyCode) {

            let key = {};
            key.code = keyCode;
            key.isDown = false;
            key.isUp = true;
            key.press = undefined;
            key.release = undefined;

            //The `downHandler`
            key.downHandler = event => {
                if (event.keyCode === key.code) {
                    if (key.isUp && key.press) key.press();
                    key.isDown = true;
                    key.isUp = false;
                }
                event.preventDefault();
            };

            //The `upHandler`
            key.upHandler = event => {
                if (event.keyCode === key.code) {
                    if (key.isDown && key.release) key.release();
                    key.isDown = false;
                    key.isUp = true;
                }
                event.preventDefault();
            };

            //Attach event listeners
            const downListener = key.downHandler.bind(key);
            const upListener = key.upHandler.bind(key);

            window.addEventListener(
                "keydown", downListener, false
            );
            window.addEventListener(
                "keyup", upListener, false
            );

            // Detach event listeners
            key.unsubscribe = () => {
                window.removeEventListener("keydown", downListener);
                window.removeEventListener("keyup", upListener);
            };

            return key;
        }
    </script>

</body>

</html>