<!DOCTYPE html>
<html>
<link rel="icon" href="data:;base64,=">
<body>
    <audio id="buttonOverAudio">
    <source src = "sound/buttonOver.mp3" type = "audio/mpeg">
    </audio>
    <label for="angle">Enter Angle:</label>
    <input type="number" id="angle" name="angle">
    <label for="power">Enter Power:</label>
    <input type="number" id="power" name="power">
    <label for="wind">Enter Wind Power:</label>
    <input type="number" id="wind" name="wind"><br><br>
    <script src="bump.js"></script>
    <script src="pixi.min.js"></script>
    <script src="pixi-filters.js"></script>




    <style>
        * {
            padding: 0;
            margin: 0
        }
    </style>
    <script type="text/javascript">
        class Bullet{
            constructor(){
                this.damageZone=0;

                this.pureDamage= 0;
                //...
                this.pow=0;
                this.angle=0;
                this.wind=0;
                this.g=0;
                
            }
        }

        var app = new PIXI.Application();
        var buttonOverAudio = document.getElementById("buttonOverAudio");

        const loader = PIXI.Loader.shared;

        var state;

        // Ticker render bullet per frame
        const bulletTicker = new PIXI.ticker.Ticker();
        bulletTicker.stop();
        // t - TimePassed
        let t;
        // v0 - Power, g - Gravity, a - WindPower
        var v0, angle, g, a;


        var spriteBullet;
        var tree;
        let sheet, sheet2;

        // Brightness adjustion matrix for filter
        var brightness = 0.2;
        var b = (brightness || 0) + 1;
        var _filter = [
            b, 0, 0, 0, 0,
            0, b, 0, 0, 0,
            0, 0, b, 0, 0,
            0, 0, 0, 1, 0
        ];

        var filter = new PIXI.filters.ColorMatrixFilter();
        filter.matrix = _filter;

        const outlineFilterBlue = new PIXI.filters.OutlineFilter(2, 0x000000);

        //Add the canvas that Pixi automatically created for you to the HTML document

        document.body.appendChild(app.view);

        // Resize the renderer to fit the window screen
        app.renderer.view.style.position = "absolute";
        app.renderer.view.style.display = "block";
        app.renderer.autoResize = true;
        app.renderer.resize(window.innerWidth, window.innerHeight);

        // create the root of the scene graph



        // Load các sprite ảnh từ spritesheet bằng file json
        var textureButton;
        var textureBullet = PIXI.Texture.fromImage('image/Bullet.png');
        loader.add("image/spriteSheet.json")
                .add("image/explosionSheet.json")
                .add('menuBackground',"image/menuBackground.jpg")
                .add('selectionBackground',"image/selectionBackground.jpg");


        loader.load((loader,resources) => {
            sheet2 = resources["image/spriteSheet.json"].spritesheet;
            sheet = resources["image/explosionSheet.json"].spritesheet;
            textureButton = [
                sheet2.textures["Play.png"],
                sheet2.textures["Options.png"],
                sheet2.textures["Exit.png"]
            ];
            console.log("Texture Loaded!");

            
            menuScene = new PIXI.Container();
            app.stage.addChild(menuScene);

            selectionScene = new PIXI.Container();
            app.stage.addChild(selectionScene);
            selectionScene.visible = false;
            selectionScene.alpha=0;

            RENDERER = app.renderer;
            RENDERER.plugins.interaction.moveWhenInside = true;

            document.body.appendChild(app.view);

            class Sprite extends PIXI.Sprite
            {
                constructor(texture)
                {
                    super(texture);
                    
                    this.refresh();
                }

                pixel(x, y)
                {
                    var pixels  = this.pixels; 
                    var index   = (y * this.width + x) * 4;
                    console.log(index);
                    console.log(index + 1);
                    console.log(index + 2);
                    console.log(index + 3);
                    return [ this.pixels[index], this.pixels[index + 1], this.pixels[index + 2], this.pixels[index + 3] ] 
                }
                
    
                refresh()
                {
                    this.pixels = RENDERER.extract.pixels(this);
                }
            }

            function move(ev)
            {
                this.refresh();
                
                var pt = ev.data.getLocalPosition(this);
                var pixel = this.pixel(pt.x, pt.y);
                console.log(pt.x);

                console.log(pt.y);

                console.log(pixel);
            }
            

            
            
            // Create a Background for Scenes
   
            const background1 = new PIXI.Sprite(resources.menuBackground.texture);
            const background2 = new PIXI.Sprite(resources.selectionBackground.texture);
            background1.width = app.renderer.width;
            background1.height = app.renderer.height;

            background2.width = app.renderer.width;
            background2.height = app.renderer.height;

            // add background to Scenes
            menuScene.addChild(background1);
            selectionScene.addChild(background2);

            // Create a bullet handler per frame
            bulletTicker.add(deltaTime => flyout(deltaTime, spriteBullet, bullet));

            // Add buttons to the menuScene
            menuButtons();

            
            // Add Tree to the menuScene

            tree = new Sprite(sheet2.textures["Bullet.png"]);



            console.log(tree.width);
            console.log(tree.height);
            pixels = tree.pixels;
            console.log(pixels);

            tree.filters = [outlineFilterBlue];
            tree.interactive = true;
            tree.on('pointermove', move);
        

            menuScene.addChild(tree);


            var black = [];

            for (i = 0; i < pixels.length / 4; i++) {
                if (pixels[4 * i] == 0 && pixels[4 * i + 1] == 0 && pixels[4 * i + 2] == 0 && pixels[4*i+3]>0)  {
                    black[i] = 1;
                } else {
                    black[i] = 0;
                }
            }

            console.log(black);




            state = menu;
            app.ticker.add(delta => gameLoop(delta));

        });



        function gameLoop(delta) {
            //Update the game current state
            //If space is pressed
            state(delta);
        }

        function play(delta) {
            //All the game logic goes here


        }

        function menu(delta) {
            //All the game logic goes here
        }

        function selection() {
            if(menuScene.alpha>0)
            {
                menuScene.alpha-=0.01;
            }
            else if(selectionScene.alpha<1){
                menuScene.visible = false;
                selectionScene.visible=true;
                selectionScene.alpha+=0.1;
            }
        }




 

        // Do something when a button is clicked
        var buttonClicked = function() 
        {
            switch(this.name){
            case "Play":
            {
                state=selection;
                break;
            }
            case "Options":
            {
                shootBullet(0.1*app.renderer.width, 0.8*app.renderer.height,0,document.getElementById("power").value,angle);
                break;
            }
            case "Exit":
        }
        }
        var shootBullet = function(x, y, type, pow, angle) {
            if(!bulletTicker.started)
            {
                bullet = new Bullet();
                spriteBullet = new PIXI.Sprite(textureBullet);
                // bullet.damageZone = damageZone[type];
                // bullet.pureDamage = pureDamage[type];
                spriteBullet.anchor.set(0.5);
                spriteBullet.x = x;
                spriteBullet.y = y;
                spriteBullet.scale.x = 0.2;
                spriteBullet.scale.y = 0.2;
                menuScene.addChild(spriteBullet);
                t = 0;
                bullet.pow = pow,
                    bullet.angle = Math.PI / 180 * document.getElementById("angle").value,
                    bullet.g = 10;
                    bullet.wind = document.getElementById("wind").value;

                bulletTicker.start();
            }
            

         
         
        };



        function onButtonDown() {
            this.isDown = true;
            this.filters = null;

        }

        function onButtonUp() {
            this.isDown = false;
            if (this.isOver) {
                this.filters = [filter];
            } else {

            }

        }

        function onButtonOver() {
            this.isOver = true;
            if (this.isDown) {
                return;
            }
            // Adjust buttonOver texture
            this.filters = [filter];

            buttonOverAudio.play();
        }

        function onButtonOut() {
            this.isOver = false;
            if (this.isDown) {
                return;
            }
            // Adjust buttonOut texture
            this.filters = null;

        }


        // Adjust bullet position per frame
            function flyout(deltaTime, spriteBullet, bullet) {

            vx = bullet.pow * Math.cos(bullet.angle) + bullet.wind * t / 10;
            vy = bullet.pow * Math.sin(bullet.angle) - bullet.g * t / 10;

            var b = new Bump();
            spriteBullet.x += vx;
            spriteBullet.y -= vy;

            t += 0.2;

            if (spriteBullet.x > app.renderer.width || spriteBullet.y > app.renderer.height ||
                spriteBullet.x < -spriteBullet.width/2 || spriteBullet.y < -spriteBullet.height/2)
            {
                menuScene.removeChild(spriteBullet);
                spriteBullet.destroy();
                bulletTicker.stop();
            }
            else if (b.hit(spriteBullet, tree)) {
                explosion = new PIXI.AnimatedSprite(sheet.animations["explosion3"]);
                explosion.anchor.set(0.5);
                explosion.visible = true;
                explosion.x = spriteBullet.x;
                explosion.y = spriteBullet.y;
                explosion.loop = false;
                explosion.animationSpeed = 0.5;

                menuScene.addChild(explosion);
                explosion.play();

                explosion.onComplete = function() {
                    menuScene.removeChild(explosion);
                    explosion.destroy();
                }
                menuScene.removeChild(spriteBullet);
                spriteBullet.destroy();
                bulletTicker.stop();
            }
            

        }

        function menuButtons() {
            // Create button array
            var buttons = [];

            // Create name array to specify buttons
            var name = [
                "Play",
                "Options",
                "Exit"
            ]

            // Create position array for buttons
            var buttonPositions = [
                app.renderer.width / 2, app.renderer.height / 5,
                app.renderer.width / 2, 2 * app.renderer.height / 5,
                app.renderer.width / 2, 3 * app.renderer.height / 5
            ];
            for (var i = 0; i < 3; i++) {
                var button = new PIXI.Sprite(textureButton[i]);
                button.buttonMode = true;

                button.anchor.set(0.5);
                button.name = name[i];
                button.position.x = buttonPositions[i * 2];
                button.position.y = buttonPositions[i * 2 + 1];

                // make the button interactive...
                button.interactive = true;


                button
                // set the mousedown and touchstart callback...
                    .on('mousedown', onButtonDown)
                    .on('touchstart', onButtonDown)

                // set the mouseup and touchend callback...
                .on('mouseup', onButtonUp)
                    .on('touchend', onButtonUp)
                    .on('mouseupoutside', onButtonUp)
                    .on('touchendoutside', onButtonUp)

                // set the mouseover callback...
                .on('mouseover', onButtonOver)

                // set the mouseout callback...
                .on('mouseout', onButtonOut)


                // you can also listen to click and tap events :
                //.on('click', shootBullet)

                button.tap = buttonClicked;
                button.click = buttonClicked;
                // add it to the app.stage
                menuScene.addChild(button);

                // add button to array
                buttons.push(button);
            }
        }
    </script>

</body>

</html>